1. float value = 102.0; //because its double
2. float value1 = (1f * 0.0);//does NOT compile, compiler says cast to float:  float value1 = (float) (1f * 0.0);
3. float value1 = 1f * (boolean)0;//does NOT compile, cannot cast int to boolean
4. /*
* /* ferret */
*/
Does not compile, everything from the first /* to the first */ is part of the comment, which mean compiler sees
something like /* */ */. there is an extra */
5. public class Animal{
    private String name;
    }
    class Animal2 {
    }
I can have two classes in the same file. However, public class needs to match the filename.
6. I can use Public as identifier, because java is case sensitive
7. Java does not have operator overloading or pointers.
8. Javac compiles .java file into .class file.
$ javac Zoo.java
$ java Zoo Zoo
if I dont pass enough arguments, java prints out an exception.
9. 0b is the prefix for a binary value and is correct. 0X is the prefix for a hexadecimal value. This value CAN
be assigned to many primitive types, including int and double.
10. int amount = 9L INCORRECT!! Correct way is: long amount=9L.
11. System.gc() suggests that Java runs the garbage collector. HOWEVER, Java is free to ignore it the request.
finalize() runs if an object attempts to be garbage collected.
12. Student lenka = new Student();-lenka is a reference to an object.
13. int i1=1_234; Correct
    double d4=1_234.0 Correct. Underscores are allowed as long as they are directly between two other digits.
14. Given the following class, which of the following calls print out Blue Jay?
    public class BirdDisplay {
    public static void main(String[] name){
    System.out.println(name[1]);
    }
    }
    Answer: java BirdDisplay Sparrow "Blue Jay"
15. public static void main (String abc[])-correct, the array operator may appear after the variable name.
16. !!! public static void main(String[] args) is the canonical main() method I NEED TO MEMORIZE IT!!!
17. everything in java.lang is automatically considered to be imported.
18. java NIO-Java.nio package ()new Input/Output) API defines buffers, which are containers for data, and other
structures and mechanisms to support buffers.
Only those imports are correct:
import java.nio.file.*;
import java.nio.file.Files;
import java.nio.file.Paths.

INCORRECT:
import java.nio.*; //wildcard only matches class names, and not "file.Files"
import java.nio.*.*; // I can only have one wildcard and it must be at the end
import java.nio.files.Paths.*;//I cannot import methods, only classes!
19. One of the reasons for using packages is so that class names dont have to be unique across all of Java.
for Date class:
import java.util.*;
import java.sql.*;    // DOES NOT COMPILE
When the class is found in multiple packages, Java gives you the compiler error:
the type is ambiguous.

import java.util.Date;
import java.sql.*; //   IT WORKS!

import java.util.Date;
import java.sql.Date; // DOES NOT COMPILE!
20. In java I dont need to pass extention, when running a program.
21. 6: public void method(ArrayList list) {
    7: if (list.isEmpty()) { System.out.println("e");
    8: } else { System.out.println("n");
    9: } }
    // CODE COMPILES. IT STARTS FROM LINE 6, AND I CAN ASSUME IMPORTS ARE THERE IN LINES 1-5.

   1: public class LineNumbers {
   2: public void method(ArrayList list) {
   3: if (list.isEmpty()) { System.out.println("e");
   4: } else { System.out.println("n");
   5: } } }
   // CODE DOES NOT COMPILE. IT STARTS ON LINE 1 AND THERE ARE NO IMPORTS!!
22. The ternary operator permitted to have expressions that dont have matching types.
23. Primitive data types:
byte=1 byte, stores whole numbers from -128 to 127
short=2 bytes, stores whole numbers from -32,768 to 32,767
int=4 bytes, stores whole numbers from -2,147,483,648 to 2,147,483,647
long=8 bytes, stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
float=4 bytes, stores fractional numbers. Sufficient for storing 6 to 7 decimal digits
double=8 bytes, stores fractional numbers. Sufficient for storing 15 decimal digits.
boolean=1 bit, stores true or false values
char=2 bytes, stores a single character/letter or ASCII values
24. I CAN use 'break' in 'for' loop.
25. two else statements cannot be chained together without addition if-then statements.
26. 3: byte a=40, b=50;
    4: byte sum = (byte)a+b;
    5: System.println(sum); // DOES NOT COMPILE BECAUSE OF LINE 4

the cast operator has the highest precedence so it is evaluated first,casting a to byte. Then the addition is
evaluated, causing both a and b to be promoted to int values. The value 90 is an int and cannot be assigned
to the byte sum without an explicit cast. to make code work, I could put (a+b).
****************************************************************************
****************************************************************************
****************************************************************************
27. ASK KRIS!
 	What is the output of the following code snippet?
3: int x1 = 50, x2 = 75;
4: boolean b = x1 >= x2;
5: if(b = true) System.out.println("Success");
6: else System.out.println("Failure");

Why A.Success??
B.Failure
C. The code will not compile because of line 4.
D. The code will not compile because of line 5.
The code compiles successfully, so options C and D are incorrect. The value of b after line 4 is false.
However, the if-then statement on line 5 contains an assignment, not a comparison.
The variable b is assigned true on line 3, and the assignment operator returns true, so line 5 executes
and displays Success, so the answer is option A.
28. 2%2=0
29.         int x=0;
            while ( ++x < 5 )
            {
                x+=1;
            }
            String message = x > 5 ? "Greater than" : "Less Than";
            System.out.println(message+","+x);

            answer is "less than, 5"
